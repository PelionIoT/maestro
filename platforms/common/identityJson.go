package common

// Copyright (c) 2018, Arm Limited and affiliates.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import (
	"encoding/hex"
	"encoding/json"
	"io"
	"io/ioutil"
	"os"

	"github.com/PelionIoT/maestro/debugging"
	"github.com/PelionIoT/maestroSpecs"
	"github.com/PelionIoT/maestroSpecs/templates"
	"github.com/mholt/archiver"
)

// format of file is:
/*
{
    "serialNumber": "SOFT0005T9",
    "OU": "00ced56faf434f3ab7cf49470977e801",
    "deviceID": "2f9aad184e404d8bbafd5ad949552cf0",
    "hardwareVersion": "SOFT_GW",
    "radioConfig": "00",
    "ledConfig": "01",
    "category": "development",
    "ethernetMAC": [
        0,
        165,
        9,
        106,
        110,
        148
    ],
    "sixBMAC": [
        0,
        165,
        9,
        0,
        1,
        106,
        110,
        148
    ],
    "hash": [],
    "gatewayServicesAddress": "https://gw.stuff.com",
    "apiServerAddress": "https://api.stuff.com",
    "cloudAddress": "https://gw.stuff.com"
}

*/
// This should be passed through the maestro config
var mcc_config_file string = "/userdata/mcc_config.tar.gz"
var mcc_untar_dir string = "/userdata/mbed/"
var mcc_config_dir string = "/userdata/mbed/mcc_config"
var mcc_config_working_dir string = "/userdata/mbed/mcc_config/WORKING"

// IdentityJSONFile is a structure which holds data which is read from identity.json - a file generated by the Pelion
// Edge Gateway provisioning tools.
type IdentityJSONFile struct {
	SerialNumber string `json:"serialNumber" dict:"SERIAL_NUMBER"`
	OU           string `json:"OU" dict:"OU"`
	DeviceID     string `json:"DeviceID" dict:"DEVICE_ID"`
	// HardwareVersion is a string identitying the type of hardware and version of hardware
	HardwareVersion string `json:"hardwareVersion" dict:"HARDWARE_VERSION"`
	EdgePlatform    string `dict:"EDGE_PLATFORM"`
	RadioConfig     string `json:"radioConfig" dict:"RADIO_CONFIG"`
	LEDConfig       string `json:"ledConfig" dict:"LED_CONFIG"`
	LEDProfile      string `json:"ledConfig" dict:"LED_COLOR_PROFILE"`
	ConfigCategory  string `json:"category" dict:"CONFIG_CATEGORY"`
	EthernetMAC     []byte `json:"ethernetMAC"`
	SixMAC          []byte `json:"sixBMAC"`
	// hash []string  // ??
	GatewayServicesAddress  string `json:"gatewayServicesAddress" dict:"GW_SERVICES_URL"`
	GatewayServicesResource string `dict:"GW_SERVICES_RESRC"`
	APIServerAddress        string `json:"apiServerAddress" dict:"API_SERVICES_URL"`
	MccConfig               string `json:"mcc_config" dict:"MCC_CONFIG"`
}

func convertByteSliceToHexString(bytes []byte) (ret string) {
	ret = hex.EncodeToString(bytes)
	return
}

func IsEmpty(name string) (bool, error) {
	f, err := os.Open(name)
	if err != nil {
		return false, err
	}
	defer f.Close()

	n, err := f.Readdirnames(1)
	if len(n) == 0 {
		return true, nil
	}
	if err == io.EOF {
		return true, nil
	}
	return false, err
}

func ReadIdentityFile(path string, dict *templates.TemplateVarDictionary, log maestroSpecs.Logger) (identityData *IdentityJSONFile, err error) {
	data, err := ioutil.ReadFile(path)

	identityData = &IdentityJSONFile{}

	if err == nil {
		err = json.Unmarshal(data, &identityData)
		debugging.DEBUG_OUT("Unmarshaled identity data from file %s ok.\n", path)
		if err == nil {
			// add all the fields with a 'dict' tag (takes care of all the top level string values)
			dict.AddTaggedStructArch(identityData)

			if len(identityData.EthernetMAC) > 0 {
				if len(identityData.EthernetMAC) != 6 {
					log.Errorf("Identity file %s has invalid length data for ethernetMAC address\n", path)
				} else {
					var eMac string = convertByteSliceToHexString(identityData.EthernetMAC)
					if len(eMac) < 12 {
						log.Error("EthernetMAC in identity appears corrupt")
					} else {
						eMac = eMac[:2] + ":" + eMac[2:4] + ":" + eMac[4:6] + ":" + eMac[6:8] + ":" + eMac[8:10] + ":" + eMac[10:12]
					}
					dict.AddArch("ETHERNET_MAC", eMac)
				}
			} else {
				log.Warnf("Identity file %s has no ethernetMAC address\n", path)
			}
			if len(identityData.SixMAC) > 0 && len(identityData.SixMAC) != 8 {
				log.Errorf("Identity file %s has invalid length data for ethernetMAC address\n", path)
			} else {
				dict.AddArch("SIXLBR_MAC", convertByteSliceToHexString(identityData.SixMAC))
			}

			// This is now redundant, in future we should remove it
			identityData.EdgePlatform = "wwgateway_v" + identityData.HardwareVersion
			dict.AddArch("EDGE_PLATFORM", identityData.EdgePlatform)

			// This is now redundant, in future we should remove it
			if identityData.LEDConfig == "02" {
				identityData.LEDProfile = "RBG"
			} else {
				identityData.LEDProfile = "RGB"
			}
			dict.AddArch("LED_COLOR_PROFILE", identityData.LEDProfile)

			// Need the Gateway services resources (without protocol), required by devicejs and devicedb configuration
			if len(identityData.GatewayServicesAddress) < 8 {
				log.Error("GatewayServicesAddress in identity appears corrupt")
			} else {
				identityData.GatewayServicesResource = identityData.GatewayServicesAddress[8:len(identityData.GatewayServicesAddress)]
			}
			dict.AddArch("GW_SERVICES_RESRC", identityData.GatewayServicesResource)

			// Validate if mcc_config directory is empty or not. If empty, then delete it
			res, _ := IsEmpty(mcc_config_working_dir)
			if res {
				// mcc_config is empty, delete it as unarchiver will not populate it otherwise
				os.RemoveAll(mcc_config_dir)
			}

			// Untar the mcc_config and save it in userdata
			mcc, err := hex.DecodeString(identityData.MccConfig)
			if err != nil {
				log.Errorf("Failed to decode mcc, error- %s\n", err)
			} else {
				err = ioutil.WriteFile(mcc_config_file, []byte(mcc), 0644)
				if err != nil {
					log.Errorf("Failed to write %s, Error- %s\n", mcc_config_file, err)
				}

				arch := archiver.NewTarGz()
				err = arch.Unarchive(mcc_config_file, mcc_untar_dir)
				if err != nil {
					log.Errorf("Failed to untar mcc_config- %s\n", err)
				}
			}

		}
	}

	return
}
